!function(l){function e(e){for(var n,r,t=e[0],o=e[1],u=e[2],a=0,i=[];a<t.length;a++)r=t[a],s[r]&&i.push(s[r][0]),s[r]=0;for(n in o)Object.prototype.hasOwnProperty.call(o,n)&&(l[n]=o[n]);for(f&&f(e);i.length;)i.shift()();return c.push.apply(c,u||[]),v()}function v(){for(var e,n=0;n<c.length;n++){for(var r=c[n],t=!0,o=1;o<r.length;o++){var u=r[o];0!==s[u]&&(t=!1)}t&&(c.splice(n--,1),e=a(a.s=r[0]))}return e}var r={},s={10:0},c=[];function a(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return l[e].call(n.exports,n,n.exports,a),n.l=!0,n.exports}a.m=l,a.c=r,a.d=function(e,n,r){a.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(a.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var t in n)a.d(r,t,function(e){return n[e]}.bind(null,t));return r},a.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(n,"a",n),n},a.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},a.p="";var n=window.webpackJsonp=window.webpackJsonp||[],t=n.push.bind(n);n.push=e,n=n.slice();for(var o=0;o<n.length;o++)e(n[o]);var f=t;c.push([47,5]),v()}({47:function(e,n,r){e.exports=r(48)},48:function(e,n,r){"use strict";r.r(n);var m=r(19),t=r(49),x=r.n(t),o=r(50),y=r.n(o);!function(){var e={step:0};(new dat.GUI).add(e,"step",0,1,.001).onChange(function(e){c.uniforms.uProgress.value=e});var o=m.default.imagesPath+"common/sample/",n=[{fileName:"1.jpg",val:void 0},{fileName:"2.jpg",val:void 0},{fileName:"3.jpg",val:void 0}],r=[],u=new THREE.TextureLoader,t=new THREE.Vector2(2048,1536);n.forEach(function(t){r.push(new Promise(function(n,r){u.load(o+t.fileName,function(e){t.val=e,n()},void 0,function(e){r(e)})}))});var a=new THREE.Scene,i=new THREE.OrthographicCamera(-1,1,1,-1,0,-1),l=new THREE.WebGLRenderer({canvas:document.querySelector("#canvas"),antialias:!0}),v=new THREE.Clock,s=new THREE.PlaneGeometry(2,2,1,1),c=new THREE.ShaderMaterial({uniforms:{uTime:{type:"f",value:0},uResolution:{type:"v2",value:new THREE.Vector2},uTexResolution:{type:"v2",value:t},uTexturePrev:{type:"t",value:void 0},uTextureNext:{type:"t",value:void 0},uProgress:{type:"f",value:e.step}},vertexShader:x.a,fragmentShader:y.a}),f=new THREE.Mesh(s,c);function d(){requestAnimationFrame(d),c.uniforms.uTime.value=v.getElapsedTime(),l.render(a,i)}function p(){var e=window.innerWidth,n=window.innerHeight;l.setPixelRatio(window.devicePixelRatio),l.setSize(e,n),c.uniforms.uResolution.value.x=e,c.uniforms.uResolution.value.y=n}a.add(f),window.addEventListener("resize",p),p(),Promise.all(r).then(function(){c.uniforms.uTexturePrev.value=n[0].val,c.uniforms.uTextureNext.value=n[1].val,d()},function(e){console.log(e)})}()},49:function(e,n){e.exports="#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}"},50:function(e,n){e.exports="#define GLSLIFY 1\nuniform vec2 uResolution;\nuniform vec2 uTexResolution;\nuniform sampler2D uTexturePrev;\nuniform sampler2D uTextureNext;\nuniform float uProgress;\nuniform float uTime;\n\nvarying vec2 vUv;\n\nvec2 mirrored(vec2 v) {\n  vec2 m = mod(v, 2.0);\n  return mix(m, 2.0 - m, step(1.0, m));\n}\n\nfloat tri(float p) {\n  return mix(p, 1.0 - p, step(0.5, p)) * 2.0;\n}\n\nvoid main() {\n  // 画像の縦横比を補正してbackground-size:coverの挙動にする\n  vec2 ratio = vec2(\n    min((uResolution.x / uResolution.y) / (uTexResolution.x / uTexResolution.y), 1.0),\n    min((uResolution.y / uResolution.x) / (uTexResolution.y / uTexResolution.x), 1.0)\n  );\n\n  vec2 uv = vec2(\n    vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n    vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n  );\n\n  vec2 accel = vec2(0.5, 2.0);\n  float progress = uProgress;\n\n  float delayValue = progress * 7.0 - vUv.y * 2.0 + vUv.x - 2.0;\n  delayValue = clamp(delayValue, 0.0, 1.0);\n\n  vec2 translateValue = progress + delayValue * accel;\n  vec2 translateValuePrev = vec2(-0.5, 1.0) * translateValue;\n  vec2 translateValueNext = vec2(-0.5, 1.0) * (translateValue - 1.0 - accel);\n\n  vec2 w = sin(sin(uTime) * vec2(0.0, 0.3) + vUv.yx * vec2(0.0, 4.0)) * vec2(0.0, 0.5);\n  vec2 xy = w * (tri(uProgress) * 0.5 + tri(delayValue) * 0.5);\n\n  vec2 uvPrev = uv + translateValuePrev + xy;\n  vec2 uvNext = uv + translateValueNext + xy;\n\n  vec4 colorPrev = texture2D(uTexturePrev, mirrored(uvPrev));\n  vec4 colorNext = texture2D(uTextureNext, mirrored(uvNext));\n\n  gl_FragColor = mix(colorPrev, colorNext, delayValue);\n}"}});