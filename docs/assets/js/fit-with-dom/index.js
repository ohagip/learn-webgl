!function(s){function e(e){for(var n,o,t=e[0],r=e[1],i=e[2],u=0,a=[];u<t.length;u++)o=t[u],c[o]&&a.push(c[o][0]),c[o]=0;for(n in r)Object.prototype.hasOwnProperty.call(r,n)&&(s[n]=r[n]);for(f&&f(e);a.length;)a.shift()();return l.push.apply(l,i||[]),v()}function v(){for(var e,n=0;n<l.length;n++){for(var o=l[n],t=!0,r=1;r<o.length;r++){var i=o[r];0!==c[i]&&(t=!1)}t&&(l.splice(n--,1),e=u(u.s=o[0]))}return e}var o={},c={9:0},l=[];function u(e){if(o[e])return o[e].exports;var n=o[e]={i:e,l:!1,exports:{}};return s[e].call(n.exports,n,n.exports,u),n.l=!0,n.exports}u.m=s,u.c=o,u.d=function(e,n,o){u.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},u.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},u.t=function(n,e){if(1&e&&(n=u(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(u.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var t in n)u.d(o,t,function(e){return n[e]}.bind(null,t));return o},u.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return u.d(n,"a",n),n},u.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},u.p="";var n=window.webpackJsonp=window.webpackJsonp||[],t=n.push.bind(n);n.push=e,n=n.slice();for(var r=0;r<n.length;r++)e(n[r]);var f=t;l.push([43,5]),v()}({43:function(e,n,o){e.exports=o(44)},44:function(e,n,o){"use strict";o.r(n);var m=o(19),t=o(45),w=o.n(t),r=o(46),y=o.n(r);!function(){var e=[],s=[],v=new THREE.Vector2(2048,1536),r=m.default.imagesPath+"common/sample/",o=[{fileName:"1.jpg",tex:void 0},{fileName:"2.jpg",tex:void 0},{fileName:"3.jpg",tex:void 0}],i=new THREE.TextureLoader;o.forEach(function(t){e.push(new Promise(function(n,o){i.load(r+t.fileName,function(e){t.tex=e,n()},void 0,function(e){o(e)})}))});var c=new THREE.Scene,l=window.scrollY,t=Math.PI/180*30,n=window.innerWidth/window.innerHeight,u=new THREE.PerspectiveCamera(60,n,1,2e3);u.position.y=-l,console.log(l,u);var f=new THREE.WebGLRenderer({canvas:document.querySelector("#canvas"),antialias:!0,alpha:!0});f.setClearColor(0,0);var d,p,x=[];function a(){requestAnimationFrame(a),u.position.y=-l,f.render(c,u)}function g(){var a,s,e=window.innerWidth,n=window.innerHeight,o=n/2/Math.tan(t);f.setPixelRatio(window.devicePixelRatio),f.setSize(e,n),u.position.z=o,u.far=2*o,u.aspect=e/n,u.updateProjectionMatrix(),a=window.innerWidth,s=window.innerHeight,$(".img_in").each(function(e,n){var o=n.getBoundingClientRect(),t=new THREE.Vector2(o.x+o.width/2,o.y+o.height/2),r=new THREE.Vector2(t.x-a/2,t.y-s/2),i=new THREE.PlaneGeometry(o.width,o.height,1,1),u=x[e];u.geometry.dispose(),u.geometry=i,u.position.set(r.x,-r.y-l,0)})}function h(){var n=new IntersectionObserver(function(e,n){e.forEach(function(e){!0===e.isIntersecting&&(console.log(e),function(o){var t=null;if(s.findIndex(function(e,n){e.elm===o&&(t=n)}),-1!==t){var e=s[t].material.uniforms.uProgress;TweenMax.to(e,1.8,{value:1,ease:Power3.easeOut})}}(e.target),n.unobserve(e.target))})},{threshold:[1]});s.forEach(function(e){n.observe(e.elm)})}d=window.innerWidth,p=window.innerHeight,$(".img_in").each(function(e,n){var o=n.getBoundingClientRect(),t=new THREE.Vector2(o.x+o.width/2,o.y+o.height/2),r=new THREE.Vector2(t.x-d/2,t.y-p/2),i=new THREE.PlaneGeometry(o.width,o.height,1,1),u=new THREE.ShaderMaterial({uniforms:{uResolution:{type:"v2",value:new THREE.Vector2(o.width,o.height)},uTexResolution:{type:"v2",value:v},uTexture:{type:"t",value:void 0},uProgress:{type:"f",value:0},uOffset:{type:"f",value:Math.floor(100*Math.random())}},vertexShader:w.a,fragmentShader:y.a}),a=new THREE.Mesh(i,u);a.position.set(r.x,-r.y-l,0),c.add(a),x.push(a),s.push({elm:n,material:u})}),window.addEventListener("resize",g),window.addEventListener("scroll",function(){l=window.scrollY}),g(),Promise.all(e).then(function(){s.forEach(function(e,n){console.log(e.material.uniforms.uTexture,o[n].tex),e.material.uniforms.uTexture.value=o[n].tex}),h(),a()},function(e){console.log(e)})}()},45:function(e,n){e.exports="#define GLSLIFY 1\nuniform vec2 uResolution;\nuniform vec2 uTexResolution;\n\nvarying vec2 vUv;\nvarying vec2 vTexUv;\n\nvoid main() {\n  // 画像の縦横比を補正してbackground-size:coverの挙動にする\n  vec2 ratio = vec2(\n  min((uResolution.x / uResolution.y) / (uTexResolution.x / uTexResolution.y), 1.0),\n  min((uResolution.y / uResolution.x) / (uTexResolution.y / uTexResolution.x), 1.0)\n  );\n\n  vec2 _vTexUv = vec2(\n  uv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n  uv.y * ratio.y + (1.0 - ratio.y) * 0.5\n  );\n\n  vUv = uv;\n  vTexUv = _vTexUv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},46:function(e,n){e.exports="#define GLSLIFY 1\nfloat random(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nuniform vec2 uResolution;\nuniform vec2 uTexResolution;\nuniform sampler2D uTexture;\nuniform float uProgress;\nuniform float uOffset;\n\nvarying vec2 vUv;\nvarying vec2 vTexUv;\n\nvoid main() {\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\n  float offset = 0.0;\n  float dispFactor = 0.08;\n  float squareSize = 30.0;\n\n  // aquare UV\n  vec2 squareNum = vec2(\n  uResolution.x / squareSize,\n  uResolution.y / squareSize\n  );\n  vec2 squareUv = vUv * squareNum;\n  vec2 intPos = floor(squareUv);\n  float disp = random(intPos * vec2(uOffset)); // 歪ます量\n  float disp2 = random(intPos * vec2(uOffset + uOffset + uOffset)); // 歪ます向き\n\n  // distotion\n  vec2 prevUv = vec2(1.0);\n  vec2 nextUv = vec2(1.0);\n\n  if (disp2 < 0.05) {\n    // ↓ to ↑\n    prevUv = vec2(vTexUv.x, vTexUv.y - uProgress * (disp * dispFactor));\n    nextUv = vec2(vTexUv.x, vTexUv.y + (1.0 - uProgress) * (disp * dispFactor));\n  } else if (disp2 < 0.1) {\n    // ← to →\n    prevUv = vec2(vTexUv.x - uProgress * (disp * dispFactor), vTexUv.y);\n    nextUv = vec2(vTexUv.x + (1.0 - uProgress) * (disp * dispFactor), vTexUv.y);\n  } else if (disp2 < 0.65) {\n    // → to ←\n    prevUv = vec2(vTexUv.x + uProgress * (disp * dispFactor), vTexUv.y);\n    nextUv = vec2(vTexUv.x - (1.0 - uProgress) * (disp * dispFactor), vTexUv.y);\n  } else {\n    // ↑ to ↓\n    nextUv = vec2(vTexUv.x, vTexUv.y - (1.0 - uProgress) * (disp * dispFactor));\n    prevUv = vec2(vTexUv.x, vTexUv.y + uProgress * (disp * dispFactor));\n  }\n\n  vec4 nextColor = texture2D(uTexture, nextUv);\n  color = mix(color, nextColor, uProgress);\n\n  gl_FragColor = color;\n}\n"}});